import * as core from "@actions/core";
import * as github from "@actions/github";
import * as fs from "fs";
import * as path from "path";

function getCoverageEmoji(percentage, threshold) {
  if (percentage >= threshold) return "🟢";
  if (percentage >= threshold * 0.8) return "🟡";
  return "🔴";
}

function formatPercentage(value) {
  return `${value.toFixed(1)}%`;
}

function getBadgeColor(coverage) {
  if (coverage >= 90) return "brightgreen";
  if (coverage >= 80) return "green";
  if (coverage >= 70) return "yellow";
  if (coverage >= 60) return "orange";
  return "red";
}

function generateCoverageBadge(coverage) {
  const avgCoverage =
    (coverage.summary.statements +
      coverage.summary.branches +
      coverage.summary.functions +
      coverage.summary.lines) /
    4;

  const color = getBadgeColor(avgCoverage);
  const message = `${avgCoverage.toFixed(1)}%`;

  return {
    schemaVersion: 1,
    label: "coverage",
    message: message,
    color: color,
  };
}

function createBadgesDirectory(coverage) {
  try {
    // Create badges directory
    const badgesDir = path.join(process.cwd(), "badges");
    if (!fs.existsSync(badgesDir)) {
      fs.mkdirSync(badgesDir, { recursive: true });
    }

    // Generate coverage badge
    const badgeData = generateCoverageBadge(coverage);
    const badgePath = path.join(badgesDir, "coverage.json");

    fs.writeFileSync(badgePath, JSON.stringify(badgeData, null, 2));
    core.info(`Created coverage badge at ${badgePath}`);

    // Also create individual metric badges
    const metrics = [
      { key: "statements", label: "statements" },
      { key: "branches", label: "branches" },
      { key: "functions", label: "functions" },
      { key: "lines", label: "lines" },
    ];

    metrics.forEach((metric) => {
      const value = coverage.summary[metric.key];
      const color = getBadgeColor(value);
      const badgeData = {
        schemaVersion: 1,
        label: metric.label,
        message: `${value.toFixed(1)}%`,
        color: color,
      };

      const metricBadgePath = path.join(badgesDir, `${metric.key}.json`);
      fs.writeFileSync(metricBadgePath, JSON.stringify(badgeData, null, 2));
      core.info(`Created ${metric.label} badge at ${metricBadgePath}`);
    });
  } catch (error) {
    core.warning(`Failed to create badges: ${error.message}`);
  }
}

function generateCoverageComment(coverage, title, showFiles, threshold) {
  const { summary, files } = coverage;
  let comment = `## ${title}\n\n`;
  // Summary section
  comment += "### 📈 Coverage Summary\n\n";
  comment += "| Metric | Coverage | Status |\n";
  comment += "|--------|----------|--------|\n";
  comment += `| **Statements** | ${formatPercentage(
    summary.statements
  )} | ${getCoverageEmoji(summary.statements, threshold)} |\n`;
  comment += `| **Branches** | ${formatPercentage(
    summary.branches
  )} | ${getCoverageEmoji(summary.branches, threshold)} |\n`;
  comment += `| **Functions** | ${formatPercentage(
    summary.functions
  )} | ${getCoverageEmoji(summary.functions, threshold)} |\n`;
  comment += `| **Lines** | ${formatPercentage(
    summary.lines
  )} | ${getCoverageEmoji(summary.lines, threshold)} |\n\n`;
  // Overall status
  const avgCoverage =
    (summary.statements +
      summary.branches +
      summary.functions +
      summary.lines) /
    4;
  const overallEmoji = getCoverageEmoji(avgCoverage, threshold);
  comment += `**Overall Coverage: ${formatPercentage(
    avgCoverage
  )} ${overallEmoji}**\n\n`;
  if (showFiles && files.length > 0) {
    comment += "### 📁 File Details\n\n";
    comment += "| File | Statements | Branches | Functions | Lines |\n";
    comment += "|------|------------|----------|-----------|-------|\n";
    files.forEach((file) => {
      const filePath = file.file
        .replace(process.cwd(), "")
        .replace(/^[\/\\]/, "");
      comment += `| \`${filePath}\` | ${formatPercentage(
        file.statements
      )} | ${formatPercentage(file.branches)} | ${formatPercentage(
        file.functions
      )} | ${formatPercentage(file.lines)} |\n`;
    });
  }
  comment +=
    "\n---\n*Generated by [@glideapps/vitest-v8-json-coverage-summary](https://github.com/glideapps/vitest-v8-json-coverage-summary)*";
  return comment;
}

async function run() {
  try {
    const coverageFile =
      core.getInput("coverage-file", { required: false }) ||
      "coverage/coverage-summary.json";
    const token =
      core.getInput("token", { required: false }) || process.env.GITHUB_TOKEN;
    const title =
      core.getInput("title", { required: false }) || "📊 Coverage Report";
    const showFiles =
      core.getInput("show-files", { required: false }) === "true";
    const threshold = parseInt(
      core.getInput("coverage-threshold", { required: false }) || "80",
      10
    );
    const makeBadges =
      core.getInput("make-badges", { required: false }) === "true";

    if (!token) {
      core.setFailed("GitHub token is required");
      return;
    }

    // Check if we're in a pull request
    const context = github.context;
    if (context.eventName !== "pull_request") {
      core.info("Not a pull request, skipping coverage comment");
      return;
    }

    // Read coverage file
    const coverageFilePath = path.resolve(coverageFile);
    if (!fs.existsSync(coverageFilePath)) {
      core.setFailed(
        `coverage-summary.json file not found at path ${coverageFilePath}. Did you forget to add the reporter in your vitest.config.js?`
      );
      return;
    }
    const coverageData = JSON.parse(fs.readFileSync(coverageFilePath, "utf8"));

    // Generate badges if enabled
    if (makeBadges) {
      createBadgesDirectory(coverageData);
    }

    // Generate comment
    const comment = generateCoverageComment(
      coverageData,
      title,
      showFiles,
      threshold
    );

    // Create GitHub client
    const octokit = github.getOctokit(token);

    // Find existing comment
    const { data: comments } = await octokit.rest.issues.listComments({
      owner: context.repo.owner,
      repo: context.repo.repo,
      issue_number: context.issue.number,
    });

    const existingComment = comments.find(
      (comment) =>
        comment.user?.type === "Bot" &&
        comment.body?.includes(
          "Generated by [@glideapps/vitest-coverage-tools]"
        )
    );

    if (existingComment) {
      // Update existing comment
      await octokit.rest.issues.updateComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        comment_id: existingComment.id,
        body: comment,
      });
      core.info("Updated existing coverage comment");
    } else {
      // Create new comment
      await octokit.rest.issues.createComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: context.issue.number,
        body: comment,
      });
      core.info("Created new coverage comment");
    }
  } catch (error) {
    core.setFailed(
      error instanceof Error ? error.message : "Unknown error occurred"
    );
  }
}

run();

// Export functions for testing
if (typeof module !== "undefined" && module.exports) {
  module.exports = {
    getCoverageEmoji,
    formatPercentage,
    getBadgeColor,
    generateCoverageBadge,
    createBadgesDirectory,
    generateCoverageComment,
  };
}
//# sourceMappingURL=action.js.map
